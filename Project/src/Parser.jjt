options {
	LOOKAHEAD=1; //melhorar para 1
	MULTI=true;
}
 
PARSER_BEGIN(Parser)

/*import java.io.BufferedReader;
import java.io.InputStreamReader; */
import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class Parser {
	static java.util.Stack argStack;
	public static void main(String[] args) throws ParseException{

		argStack = new java.util.Stack(); 

		File filename = new File(args[0]);
	  	try { 
			Parser parser = new Parser(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			root.dump("");
		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(Parser)

SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." > //Ã© para por isto?
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module(): {Token moduleName;} {
	try {
		<MODULE> moduleName=<ID> 

		{jjtThis.name = moduleName.image; }

		<LCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on module start, with Exception thrown " + e.toString());
		Token t = getToken(0);
		if (t.kind == LCHAVETA) 
			getNextToken();
		else
			error_skipto(PVIRG);
	}
	
	(Function() |
	Declaration())*
		
	try {
		< RCHAVETA > { return jjtThis; }
	} catch (ParseException e) {
		System.out.println("Error on module end, with Exception thrown " + e.toString());
		return jjtThis;	
	}
}

void Declaration(): {String declaration; Token tmp;} {

	try {	
		<ID> (ArrayElement())?
		(< ASSIGN > (("[" ArraySize() "]") | (< ADDSUB_OP >)? < INTEGER >))? < PVIRG >
	}
	catch(ParseException e) {
		System.out.println("Error on declaration, with Exception thrown " + e.toString());

		error_skipto(PVIRG);
	}
}

void Function(): {Token name;} {
	try {
	 	<FUNCTION>  name=<ID> {jjtThis.functionName = name.image;} (
	     	((ArrayElement())? <ASSIGN> <ID>)?
		     (VarList()) 
		)	
	} catch(ParseException e) {
		System.out.println("Error on function statement, with Exception thrown " + e.toString());
		error_skipto(PVIRG);
	} 
	
	Stmtlst() 
}

void VarList(): {String variables; Token tmp;} { 
	
	{variables = "";}

	try {
		<LPAR>
	} catch (ParseException e) {
		System.out.println("Error on argument list, no opening parenthesis. \nSpecific Exception thrown: " + e.toString());
	}
	try {
	 	(tmp=<ID> {variables += " " + tmp.image;} (ArrayElement() {variables += "[]";})?
		
		(< VIRG > tmp=<ID> 
			{variables += ", " + tmp.image; }  
			(ArrayElement() {variables += "[]";})?
		)*)? 

		<RPAR>

		{jjtThis.varList = variables;}

	} catch (ParseException e) {
		System.out.println("Error on argument list variables or closing parenthesis. \nSpecific Exception thrown: " + e.toString());

		error_skipto_unless(PVIRG, RPAR);
	}
}

void ArrayElement() #void: { } {
	"[" "]"
}

void Stmtlst() #void: {} {
	try {
		<LCHAVETA>
	} 
	catch (ParseException e) {
		System.out.println("Error on statement list, opening bracket not detected."
			+"\nSpecific exception: " + e.toString());
		error_skipto_withoutconsuming(ID);
		return;
	}

	(Stmt())* 
	
	try {
		<RCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on statement list, closing bracket not detected."
			+"\nSpecific exception: " + e.toString());
		error_skipto(ID);
	}
}

// Statements

void Stmt() #void: {Token t;} {
	try {
		
		While() | If() | (t=<ID> (LOOKAHEAD(2) Call(t) | Assign(t))) < PVIRG >

	} catch (ParseException e) {
		System.out.println("Error on a statement, maybe missing ';'\nSpecific Exception thrown: ." + e.toString());
		error_skipto(PVIRG);
	}
}

void Call(Token t): {String string; Token tmp;} {
	try {

		( < DOT > tmp=<ID > {jjtThis.calledFunction = tmp.image;})?  < LPAR > (ArgumentList() )? < RPAR >
		{ jjtThis.value = t.image;  }
	} catch (ParseException e) {
		System.out.println("Error on call."
			+"\nSpecific exception: " + e.toString());
		error_skipto_unless(PVIRG, LCHAVETA);
	}
}

void Assign(Token t): {String string;} {
	try {
		string=LhsNoID()
		{jjtThis.value1= t.image+" "+string;} <ASSIGN> 
		string=Rhs()
		{jjtThis.value2=string;}
	} catch (ParseException e) {
		System.out.println("Error on assign."
			+"\nSpecific exception: " + e.toString());
		
		error_skipto(PVIRG);
	}
}

void While(): { } {
	try {
		< WHILE > Exprtest() Stmtlst() 
	} catch (ParseException e) {
		System.out.println("Error on while");
	}
}

void If(): { } {
	try {
		< IF > Exprtest() Stmtlst() 
	} catch (ParseException e) {
		System.out.println("Error on if");
	}

	try {
		(< ELSE > Stmtlst())?
	}
	catch (ParseException e) {
		System.out.println("Error on else");
		error_skipto(PVIRG);
	}
}

// Left and Right terms

String Lhs() #void: {String string; Token tmp;} {
	tmp=<ID>  (string=ArrayAccess() | string=ScalarAccess()) 
	{return tmp.image + string;}
}

String LhsNoID() #void: {String string;} {
	(string=ArrayAccess() | string=ScalarAccess())
	{ return string;}
}

String Rhs() #void: { String string; Token tmp; String tmpString;} {
	try {
	(
	(
	string=Term() ((tmp=< ARITH_OP > | tmp=< BITWISE_OP > | tmp=< ADDSUB_OP >) tmpString=Term() {string += " " + tmp + " " + tmpString;})?
	) | ("[" tmpString=ArraySize() "]" {string="["+tmpString+"]";})
	)
	
	{return string;}

	}
	catch (ParseException e) {
		System.out.println("Error on rhs.\nSpecific Exception thrown: " + e.toString());
		error_skipto_withoutconsuming(PVIRG);
	}
	
}


String Term() #void: {Token t; String string; } {

	{string="";}
	try {
		( t=<ADDSUB_OP> 
			{string=t.image;} )? 

		( (t=<INTEGER> {string+=t.image;} ) 
		 | ( t=<ID> ( ArrayAccess() | 
		(LOOKAHEAD(2) Call(t) | ScalarAccess() ))))

		{return string;}
	}
	catch (ParseException e) {
		System.out.println("Error on term.\nSpecific Exception: " + e.toString());
		error_skipto_withoutconsuming(PVIRG);
	}
} 

void Exprtest(): { } {
	try {
		< LPAR > Lhs() 
	} catch (ParseException e) {
		System.out.println("Invalid opening condition for structure. \nSpecific Exception thrown: " + e.toString());
		error_skipto_withoutconsuming(RELA_OP);
	}
	try {
		< RELA_OP >	Rhs() <RPAR>
	}
	catch (ParseException e) {
		System.out.println("Invalid comparison operation or ending condition for structure. \nSpecific Exception thrown: "
		 + e.toString());
			error_skipto_unless(PVIRG, RPAR);
	}
}


// Arguments

void ArgumentList(): {String string; String tmp; } {
	try {

	string=Argument() (< VIRG > tmp=Argument() {string += ", " + tmp;})*

	{jjtThis.argumentList = string;}

	} catch (ParseException e) {

		System.out.println("Invalid argument. \nSpecific Exception thrown: " + e.toString());
		error_skipto(RPAR);

	}
}

String Argument() #void : {Token t; } {
	 (t=<ID> | t=<STRING> | t=<INTEGER> ){return t.image;}
}

// Access

String ArraySize() #void: {String size; Token tmp; String tmpString;} {
	{size = ""; tmpString="";}

	tmp=<ID> 

	{ size += tmp.image; }

	 ((tmpString=ScalarAccess() {size += tmpString;}) | (tmp=< INTEGER > {size += tmp.image;}))

	{System.out.println("Tentei tirar o size, com valor " + size); return size;} 
}

String ArrayAccess() #void :  {String index;} {
	"[" index=Index() "]"
	 {return "[" + index + "]"; }
}

String ScalarAccess() #void :  {Token size; } {
	(<DOT > size=< SIZE > {return "." + size.image;})?
	{return "";}
}


String Index(): {Token value;} {
	value=< ID > | value=< INTEGER >
	{return value.image;}
}


// For Error Recovery


JAVACODE
void error_skipto(int kind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
}


JAVACODE
void error_skipto_unless(int kind, int stopKind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind && t.kind != stopKind);
}

JAVACODE
void error_skipto_withoutconsuming(int kind) {
  Token t;

  boolean hasReached = false;
  while (!hasReached) {
  	t = getToken(1);
  	if (t.kind == kind)
  		hasReached = true;
  	else 
  		getNextToken();
  }
}

