options {
	LOOKAHEAD=1; //melhorar para 1
}
 
PARSER_BEGIN(Parser)

/*import java.io.BufferedReader;
import java.io.InputStreamReader; */
import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class Parser {
	static java.util.Stack argStack;
	public static void main(String[] args) throws ParseException{

		argStack = new java.util.Stack(); 

		File filename = new File(args[0]);
	  	try { 
			Parser parser = new Parser(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			root.dump("");
		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(Parser)

SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." > //Ã© para por isto?
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module(): {} {
	try {
	<MODULE> <ID> <LCHAVETA>
	 (Declaration())* 
	 (Function())* 
	 {System.out.println("3");}
	 < RCHAVETA > { return jjtThis; }
	}
	catch (ParseException e) {
    	System.out.println("Erro no module, mais especificamente no " + exceptionCause(e));
    	Token t;
    	do {
      		t = getNextToken();
      		System.out.println("Estou a continuar? " + t.image);
      		
    	} while (t.kind != RCHAVETA);
    	
    	return jjtThis;
  	}
}

void Declaration(): {} {
	try {	
		<ID> (ArrayElement())?
		(< ASSIGN > (("[" ArraySize() "]") | (< ADDSUB_OP >)? < INTEGER >))? < PVIRG >
	}
	catch(ParseException e) {
		System.out.println("Erro no declaration");
	}
}

String exceptionCause(ParseException e):{} {
	{return e.toString();}
}

void Function(): {} {
	 <FUNCTION>  <ID> (
	     ((ArrayElement())? <ASSIGN> <ID>)?
	    <LPAR> (VarList())? < RPAR >
	)
	< LCHAVETA > Stmtlst() < RCHAVETA >
	
}

void VarList(): { } {
	 <ID>(ArrayElement())?
	(
	  < VIRG > <ID> (ArrayElement())?
	)*
}

void ArrayElement(): { } {
	"[" "]"
}

void Stmtlst(): { } {
	( Stmt() )*
}

void Stmt(): {} {
	 	While() | If() | (LOOKAHEAD(2) (Assign() | (<ID> Call()))) < PVIRG >
}

void Call(): { } {
	( < DOT > <ID >)? < LPAR > (ArgumentList() )? < RPAR >
}

void Assign(): { } {
	Lhs() <ASSIGN> Rhs()
}

void Lhs(): {} {
	<ID>  (ArrayAccess() | ScalarAccess())
}

void Rhs(): { } {
	(
	  Term() ((< ARITH_OP > | < BITWISE_OP > | < ADDSUB_OP >) Term())?
	) | "[" ArraySize() "]"
}

void ArraySize(): { } {
	(<ID> ScalarAccess()) | < INTEGER > 
}

void Term(): { } {
	( <ADDSUB_OP> )? 
	( <INTEGER> | ( <ID> ( ArrayAccess() | 
		(LOOKAHEAD(2) Call() | {System.out.print("Term1 ");}ScalarAccess() {System.out.println("Term2 ");}))))
} 

void Exprtest(): { } {
	< LPAR > Lhs() < RELA_OP > Rhs() <RPAR >
}

void While(): { } {
	< WHILE > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA >
}

void If(): { } {
	< IF > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA > (< ELSE > <LCHAVETA > Stmtlst() <RCHAVETA >)?
}

void ArgumentList(): { } {
	Argument() (< VIRG > Argument())*
}

void Argument(): { } {
	 < ID > | < STRING > | < INTEGER > 
}

void ArrayAccess(): { } {
	"[" Index() "]"
}

void ScalarAccess(): { } {
	(<DOT > < SIZE >)?
}

void Index(): {} {
	< ID > | < INTEGER >
}



