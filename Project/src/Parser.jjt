options {
	LOOKAHEAD=1; //melhorar para 1
}
 
PARSER_BEGIN(Parser)

/*import java.io.BufferedReader;
import java.io.InputStreamReader; */
import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class Parser {
	static java.util.Stack argStack;
	public static void main(String[] args) throws ParseException{

		argStack = new java.util.Stack(); 

		File filename = new File(args[0]);
	  	try { 
			Parser parser = new Parser(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			root.dump("");
		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(Parser)

SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." > //Ã© para por isto?
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module(): {} {
	try {
		<MODULE> <ID> <LCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on module start, with Exception thrown " + e.toString());
		error_skipto(PVIRG);
	}
	try {
		(Declaration())* 
		(Function())* 
	} catch (ParseException e) {
		System.out.println("Error on declaration or function, with Exception thrown " + e.toString());
		error_skipto(PVIRG);
	}
	try {
		< RCHAVETA > { return jjtThis; }
	} catch (ParseException e) {
		System.out.println("Error on module, with Exception thrown " + e.toString());
		return jjtThis;	
	}
}

void Declaration(): {} {
	try {	
		<ID> (ArrayElement())?
		(< ASSIGN > (("[" ArraySize() "]") | (< ADDSUB_OP >)? < INTEGER >))? < PVIRG >
	}
	catch(ParseException e) {
		System.out.println("Error on declaration, with Exception thrown " + e.toString());
		error_skipto(PVIRG);
	}
}

void Function(): {} {
	try {
	 	<FUNCTION>  <ID> (
	     	((ArrayElement())? <ASSIGN> <ID>)?
		    <LPAR> (VarList())? < RPAR >
		)
		< LCHAVETA > Stmtlst() < RCHAVETA >
	} catch(ParseException e) {
		System.out.println("Error on function statement, with Exception thrown " + e.toString());
		error_skipto(PVIRG);
	}
	
}

void VarList(): { } {
	 <ID>(ArrayElement())?
	(
	  < VIRG > <ID> (ArrayElement())?
	)*
}

void ArrayElement(): { } {
	"[" "]"
}

void Stmtlst(): { } {
	( Stmt() )*
}

void Stmt(): {} {
	 While() | If() | (<ID> (LOOKAHEAD(2) Call() | Assign())) < PVIRG >
}

void Call(): { } {
	( < DOT > <ID >)? < LPAR > (ArgumentList() )? < RPAR >
}

void Assign(): { } {
	LhsNoID() <ASSIGN> Rhs()
}

void Lhs(): {} {
	<ID>  (ArrayAccess() | ScalarAccess())
}

void LhsNoID(): {} {
	(ArrayAccess() | ScalarAccess())
}

void Rhs(): { } {
	(
	  Term() ((< ARITH_OP > | < BITWISE_OP > | < ADDSUB_OP >) Term())?
	) | "[" ArraySize() "]"
}

void ArraySize(): { } {
	(<ID> ScalarAccess()) | < INTEGER > 
}

void Term(): { } {
	( <ADDSUB_OP> )? 
	( <INTEGER> | ( <ID> ( ArrayAccess() | 
		(LOOKAHEAD(2) Call() | ScalarAccess() ))))
} 

void Exprtest(): { } {
	< LPAR > Lhs() < RELA_OP > Rhs() <RPAR >
}

void While(): { } {
	< WHILE > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA >
}

void If(): { } {
	< IF > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA > (< ELSE > <LCHAVETA > Stmtlst() <RCHAVETA >)?
}

void ArgumentList(): { } {
	Argument() (< VIRG > Argument())*
}

void Argument(): { } {
	 < ID > | < STRING > | < INTEGER > 
}

void ArrayAccess(): { } {
	"[" Index() "]"
}

void ScalarAccess(): { } {
	(<DOT > < SIZE >)?
}

void Index(): {} {
	< ID > | < INTEGER >
}

JAVACODE
void error_skipto(int kind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
}



