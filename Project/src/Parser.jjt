options {
	LOOKAHEAD=3; //melhorar para 1
}
 
PARSER_BEGIN(Parser)

/*import java.io.BufferedReader;
import java.io.InputStreamReader; */
import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class Parser {
	static java.util.Stack argStack;
	public static void main(String[] args) throws ParseException{

		/*BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		String line = reader.readLine();*/
		
		 argStack = new java.util.Stack(); 

		File filename = new File(args[0]);
	  	try { 
			Parser parser = new Parser(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			root.dump("");
		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(Parser)

<DEFAULT> SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
<DEFAULT> TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." > //Ã© para por isto?
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

<DEFAULT> TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module(): {} {
	try {
	<MODULE> <ID> <LCHAVETA> (Declaration())*/*(Declaration_Array() | Declaration_Scalar())**/ (Function())* < RCHAVETA > { return jjtThis; }
	}
	catch (ParseException e) {
    	System.out.println("Erro no module, mais especificamente no " + exceptionCause(e));
    	Token t;
    	do {
      		t = getNextToken();
      		System.out.println("Estou a continuar? " + t.image);
      		
    	} while (t.kind != RCHAVETA);
    	 return jjtThis;
    	//e.printStackTrace();
  	}
}

void Declaration(): {} {
	try {	
		( ArrayElement() | ScalarElement())
		(< ASSIGN > (("[" ArraySize() "]") | (< ADDSUB_OP >)? < INTEGER >))? < PVIRG >
	}
	catch(ParseException e) {
		System.out.println("Erro no declaration");
	}

}

String exceptionCause(ParseException e):{} {
	{return e.toString();}
}
/*
void Declaration_Array(): {} {
	try {
		ArrayElement() ( < ASSIGN > (( "[" ArraySize() "]") | (<ADDSUB_OP> )? <INTEGER>))? <PVIRG>
	}
	catch(ParseException e) {
		System.out.println("Erro no declaration_array");
	}
	
}

void Declaration_Scalar(): {} {
	try {
		ScalarElement() ( < ASSIGN > (( "[" ArraySize() "]") | (<ADDSUB_OP> )? <INTEGER>))? <PVIRG>
	}
	catch(ParseException e) {
		System.out.println("Erro no declaration_scalar");
	}
}*/

void Function(): { } {
	(	  (	    < FUNCTION > (ArrayElement() | ScalarElement()) <ASSIGN> <ID>
	    <LPAR> (VarList())? < RPAR >
	  ) |
	  (		< FUNCTION > <ID> <LPAR> (VarList())? <RPAR>
	  )
	) < LCHAVETA > Stmtlst() < RCHAVETA >
	
}

void VarList(): { } {
	(	  ArrayElement() | ScalarElement()
	)
	(	  < VIRG > (ArrayElement() | ScalarElement() )
	)*
}

void ArrayElement(): { } {
	< ID > "[" "]"
}

void ScalarElement(): { } {
	< ID >
}

void Stmtlst(): { } {
	( Stmt() )*
}

void Stmt(): { } {
	While() | If() | Assign() | Call() < PVIRG >
}

void Assign(): { } {
	Lhs() <ASSIGN> Rhs() < PVIRG >
}

void Lhs(): { } {
	ArrayAccess() | ScalarAccess()
}

void Rhs(): { } {
	(	  Term() ((< ARITH_OP > | < BITWISE_OP > | < ADDSUB_OP >) Term())?
	) | "[" ArraySize() "]"
}

void ArraySize(): { } {
	ScalarAccess() | < INTEGER >
}

void Term(): { } {
	( < ADDSUB_OP >)? (< INTEGER > | Call() | ArrayAccess() | ScalarAccess() )
}

void Exprtest(): { } {
	< LPAR > Lhs() < RELA_OP > Rhs() <RPAR >
}

void While(): { } {
	< WHILE > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA >
}

void If(): { } {
	< IF > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA > (< ELSE > <LCHAVETA > Stmtlst() <RCHAVETA >)?
}

void Call(): { } {
	< ID > ( < DOT > <ID >)? < LPAR > (ArgumentList() )? < RPAR >
}

void ArgumentList(): { } {
	Argument() (< VIRG > Argument())*
}

void Argument(): { } {
	( < ID > | < STRING > | < INTEGER > )
}

void ArrayAccess(): { } {
	< ID > "[" Index() "]"
}

void ScalarAccess(): { } {
	< ID > (<DOT > < SIZE >)?
}

void Index(): {} {
	< ID > | < INTEGER >
}



