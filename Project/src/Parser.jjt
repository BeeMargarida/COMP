options {
	LOOKAHEAD=1; //melhorar para 1
	MULTI=true;
}
 
PARSER_BEGIN(Parser)

import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class Parser {
	static java.util.Stack argStack;
	public static void main(String[] args) throws ParseException{

		argStack = new java.util.Stack(); 

		File filename = new File(args[0]);
	  	try { 
			Parser parser = new Parser(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			root.dump("");
		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(Parser)

SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." >
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

// MAIN BLOCKS OF INFORMATION

/**
 * Main Module
*/
SimpleNode Module(): {Token moduleName;} {
	try {
		<MODULE> moduleName=<ID> 

		{jjtThis.name = moduleName.image; }

		<LCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on module start, with Exception thrown " + e.toString());
		Token t = getToken(0);
		if (t.kind == LCHAVETA) 
			getNextToken();
		else
			error_skipto(PVIRG);
	}
	
	(Declaration())*
	(Function())*
		
	try {
		< RCHAVETA > { return jjtThis; }
	} catch (ParseException e) {
		System.out.println("Error on module end, with Exception thrown " + e.toString());
		return jjtThis;	
	}
}

/**
 * Function, where the file's statement list lies.
*/
void Function(): {Token name;} {
	try {
	 	<FUNCTION>  name=<ID> {jjtThis.functionName = name.image;} (
	     	((ArrayElement())? <ASSIGN> name=<ID> {jjtThis.functionName = name.image;})?
		     (VarList()) 
		)	
	} catch(ParseException e) {
		System.out.println("Error on function statement, with Exception thrown " + e.toString());
		error_skipto(PVIRG);
	} 
	
	Stmtlst() 
}

/**
 * Declaration, handling definitions and assignment of variables outside functions.
*/
void Declaration(): {String declaration; Token tmp;} {

	try {	
		<ID> (ArrayElement())?
		(< ASSIGN > (("[" ArraySize() "]") | (< ADDSUB_OP >)? < INTEGER >))? < PVIRG >
	}
	catch(ParseException e) {
		System.out.println("Error on declaration, with Exception thrown " + e.toString());

		error_skipto(PVIRG);
	}
}

/**
 * VarList, the set of variables of a specific function.
*/
void VarList(): {String variables; Token tmp;} { 
	
	{variables = "";} // Initialization of variable to avoid errors.

	try {
		<LPAR>
	} catch (ParseException e) {
		System.out.println("Error on argument list, no opening parenthesis.");
		System.out.println("Specific Exception thrown:" + e.toString());
		
	}
	try {
		 	{String var = "";}
		 	(tmp=<ID> {var += tmp.image;} (ArrayElement() {var += "[]";})?
		
			(< VIRG > tmp=<ID> {var="";}
				{var += tmp.image; }  
				(ArrayElement() {var += "[]";})? 
			)*
		)? 

		<RPAR>


	} catch (ParseException e) {
		System.out.println("Error on argument list variables or closing parenthesis.");
		System.out.println("Specific Exception thrown: "+ e.toString());
		 

		error_skipto_unless(PVIRG, RPAR);
	}
}

/**
 * StmtList, the set of all statements inside a function. Opening and 
 * closing brackets are inside this list, to better detect and isolate 
 * exceptions thrown.
*/
void Stmtlst() #void: {} {
	try {
		<LCHAVETA>
	} 
	catch (ParseException e) {
		System.out.println("Error on statement list, opening bracket not detected."
			+"\nSpecific exception: " + e.toString());
		error_skipto_withoutconsuming(ID);
		return;
	}

	(Stmt())* 
	
	try {
		<RCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on statement list, closing bracket not detected."
			+"\nSpecific exception: " + e.toString());
		error_skipto(ID);
	}
}

// STATEMENT INFORMATION

/**
 * Statement, the main code unit inside a function. It includes the assign
 * of variables, the call of functions, if/else blocks and while loops.
*/
void Stmt() #void: {Token t;} {
	try {
		
		While() | (If() Else()) | (t=<ID> (LOOKAHEAD(2) Call(t) | Assign(t))) < PVIRG >

	} catch (ParseException e) {
		System.out.println("Error on a statement, maybe missing ';'\nSpecific Exception thrown: ." 
		+ e.toString());
		error_skipto(PVIRG);
	}
}

/**
 * Call, where a method is invoked.
 * @param Token t contains ID information for printing.
*/
void Call(Token t): {String string; Token tmp;} {
	try {

		( < DOT > tmp=<ID > {jjtThis.calledFunction = tmp.image;})?  < LPAR > (ArgumentList() )? < RPAR >
		{ jjtThis.value = t.image;  }
	} catch (ParseException e) {
		System.out.println("Error on call."
			+"\nSpecific exception: " + e.toString());
		error_skipto_unless(PVIRG, LCHAVETA);
	}
}

/**
 * Assign to handle all the assignment of variables, be they scalar or arrays.
 * @param Token t contains ID information for printing.
*/
void Assign(Token t): {String string;} {
	try {
		LhsNoID()
		<ASSIGN> 
		Rhs()
	} catch (ParseException e) {
		System.out.println("Error on assign."
			+"\nSpecific exception: " + e.toString());
		
		error_skipto(PVIRG);
	}
}

/**
 * While loop.
*/
void While(): {Token t; String tmp; } {
	try { 
		< WHILE > Exprtest() Stmtlst() 
	} catch (ParseException e) {
		System.out.println("Error on while");
	}
}



/**
 * If block.
*/
void If(): { String tmp; } {
	try {
		< IF > Exprtest() Stmtlst() 
	} catch (ParseException e) {
		System.out.println("Error on if");
	}

	
}

/**
 * Else block, may or may not exist after if block,
*/
void Else(): {} {
	try {
		(< ELSE > Stmtlst())?
	}
	catch (ParseException e) {
		System.out.println("Error on else");
		error_skipto(PVIRG);
	}
}

/**
 * Lhs, the left side of a two-sided operation, such as a comparison or assigment.
 * @return String containing information of lhs block.
*/
void Lhs() : {} {
	<ID>  (ArrayAccess() | ScalarAccess()) 
}

/**
 * LhsNoID, particular use of Lhs, specific for a function to remove ambiguity 
 * while maintaining readability.
 * @return String containing information of lhs block, excluding <ID>.
*/
void LhsNoID(): {} {
	(ArrayAccess() | ScalarAccess())
}

/**
 * Rhs, the right side of a two-sided operation, such as a comparison or assigment.
 * @return String containing information of right block.
*/
void Rhs(): {Token t;} {
	try {
	(
		(
		Term()((t=< ARITH_OP > | t=< BITWISE_OP > | t=< ADDSUB_OP >) Term() 
			{jjtThis.operator= t.image;})?
		) 
		|
		 ("[" ArraySize() "]")
	)
	 

	}
	catch (ParseException e) {
		System.out.println("Error on rhs.\nSpecific Exception thrown: " + e.toString());
		error_skipto_withoutconsuming(PVIRG);
	}
	
}

/**
 * Term, a subset of a Rhs.
*/
void Term(): {Token t;  } {
	try {
		( t=<ADDSUB_OP> 
			{jjtThis.operator=t.image;} )? 

		( (<INTEGER> ) 
			|
		 ( <ID> ( (ArrayAccess() ) 
		  	| 
			(LOOKAHEAD(2) Call(t) | (ScalarAccess()
			 ))
			)
		 	)
		 )

		

	} catch (ParseException e) {
		System.out.println("Error on term.\nSpecific Exception: " + e.toString());
		error_skipto_withoutconsuming(PVIRG);
	}
} 

/**
 * Exprtest, handles the small comparison block, present in the while and if blocks.
 * @return String containing information of right block.
*/
void Exprtest(): {Token t; } {
	
	try {
		< LPAR > Lhs() 
	} catch (ParseException e) {
		System.out.println("Invalid opening condition for structure. \nSpecific Exception thrown: "
		 + e.toString());
		error_skipto_withoutconsuming(RELA_OP);
	}
	try {
		t=< RELA_OP > {jjtThis.relOp = t.image;}
		Rhs()  <RPAR> 
	}
	catch (ParseException e) {
		System.out.println("Invalid comparison operation or ending condition for structure");
		 System.out.println("Specific exception thrown: " + e.toString());
		 
			error_skipto_unless(PVIRG, RPAR);
	}
}

// ARGUMENTS

/**
 * Argument List, storing the information of the arguments passed inside a call, for example.
*/
void ArgumentList(): {String string; String tmp; } {
	try {

	string=Argument() (< VIRG > tmp=Argument() {string += ", " + tmp;})*

	{jjtThis.argumentList = string;}

	} catch (ParseException e) {

		System.out.println("Invalid argument. \nSpecific Exception thrown: " + e.toString());
		error_skipto(RPAR);

	}
}

/**
 * Argument, could be an ID, String or integer. 
 * @return String containing information of argument.
*/
String Argument() #void : {Token t; } {
	 (t=<ID> | t=<STRING> | t=<INTEGER> ){return t.image;}
}

// ACCESS

/**
 * Array Size. Contains the information of the size of an array
 * @return String with the information of the array size.
*/
String ArraySize() #void: {String size; Token tmp; String tmpString;} {
	{size = ""; tmpString="";}

	tmp=<ID> 

	{ size += tmp.image; }

	 ((tmp=< INTEGER > {size += tmp.image;}) | ((tmpString=ScalarAccess()) {size += tmpString;}))

	{return size;} 
}

/**
 * Array Access, accessing information of an array.
 * @return String containing information of array access, specifically the index..
*/
String ArrayAccess() #void :  {String index;} {
	"[" index=Index() "]"
	 {return "[" + index + "]"; }
}

/**
 * Scalar Access.
 * @return String containing information of size, or nothing if no '.' is found.
*/
String ScalarAccess() #void :  {Token size; } {
	(<DOT > size=< SIZE > {return "." + size;})?
	{return "";}
}


/**
 * Index of an array.
 * @return String with index.
*/
String Index() #void: {Token value;} {
	value=< ID > | value=< INTEGER >
	{return value.image;}
}

/**
 * Array Element, checks to see if the element is correctly formatted, important for
 * error recovery.
*/
void ArrayElement() #void: { } {
	"[" "]"
}


// ERROR RECOVERY

/**
 * Skips all tokens until a specific character is found.
*/
JAVACODE
void error_skipto(int kind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
}


/**
 * Skips all tokens until a specific character is found, or another more important
 * but less likely token appears unexpectedly.
*/
JAVACODE
void error_skipto_unless(int kind, int stopKind) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind && t.kind != stopKind);
}

/**
 * Skips all tokens until a specific character, without consuming that specific token.
*/
JAVACODE
void error_skipto_withoutconsuming(int kind) {
  Token t;

  boolean hasReached = false;
  while (!hasReached) {
  	t = getToken(1);
  	if (t.kind == kind)
  		hasReached = true;
  	else 
  		getNextToken();
  }
}

