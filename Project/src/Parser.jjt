options {
	LOOKAHEAD=3; //melhorar para 1
}

PARSER_BEGIN(Parser)

/*import java.io.BufferedReader;
import java.io.InputStreamReader; */
import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class Parser {
	public static void main(String[] args) throws ParseException{

		/*BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		String line = reader.readLine();*/

		File filename = new File(args[0]);
	  	try { 
			Parser parser = new Parser(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			root.dump("");
		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(Parser)

<DEFAULT> SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
<DEFAULT> TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." > //é para por isto?
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <LBRACKET: "[" > //necess�rio?
	| <RBRACKET: "]" > 
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

<DEFAULT> TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]> //tirei os # - tecnicamente significam private ou algo do g�nero
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module(): {} {
	<MODULE> <ID> < LCHAVETA > (Declaration())* (Function())* < RCHAVETA > {  return jjtThis; }
}

void Declaration(): {Token element, size;} {
	(ArrayElement() | ScalarElement())
	(	  < ASSIGN > (( <LBRACKET> ArraySize() <RBRACKET>) | (<ADDSUB_OP> )? <INTEGER>)
	)? <PVIRG>	  //isto est� mal
}

void Function(): { } {
	(	  (	    < FUNCTION > (ArrayElement() | ScalarElement()) <ASSIGN> <ID>
	    <LPAR> (VarList())? < RPAR >
	  ) |
	  (		< FUNCTION > <ID > <LPAR > (VarList())? < RPAR >
	  )
	) < LCHAVETA > Stmtlst() < RCHAVETA >
}

void VarList(): { } {
	(	  ArrayElement() | ScalarElement()
	)
	(	  < VIRG > (ArrayElement() | ScalarElement() )
	)*
}

void ArrayElement(): { } {
	< ID > <RBRACKET > <LBRACKET >
}

void ScalarElement(): { } {
	< ID >
}

void Stmtlst(): { } {
	( Stmt() )*
}

void Stmt(): { } {
	While() | If() | Assign() | Call() < PVIRG >
}

void Assign(): { } {
	Lhs() <ASSIGN> Rhs() < PVIRG >
}

void Lhs(): { } {
	ArrayAccess() | ScalarAccess()
}

void Rhs(): { } {
	(	  Term() ((< ARITH_OP > | < BITWISE_OP > | < ADDSUB_OP >) Term())?
	) | < RBRACKET > ArraySize() < LBRACKET >
}

void ArraySize(): { } {
	ScalarAccess() | < INTEGER >
}

void Term(): { } {
	( < ADDSUB_OP >)? (< INTEGER > | Call() | ArrayAccess() | ScalarAccess() )
}

void Exprtest(): { } {
	< LPAR > Lhs() < RELA_OP > Rhs() <RPAR >
}

void While(): { } {
	< WHILE > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA >
}

void If(): { } {
	< IF > Exprtest() <LCHAVETA > Stmtlst() <RCHAVETA > (< ELSE > <LCHAVETA > Stmtlst() <RCHAVETA >)?
}

void Call(): { } {
	< ID > ( < DOT > <ID >)? < LPAR > (ArgumentList() )? < RPAR >
}

void ArgumentList(): { } {
	Argument() (< VIRG > Argument())*
}

void Argument(): { } {
	( < ID > | < STRING > | < INTEGER > )
}

void ArrayAccess(): { } {
	< ID > <RBRACKET > Index() < LBRACKET >
}

void ScalarAccess(): { } {
	< ID > (<DOT > < SIZE >)?
}

void Index(): {} {
	< ID > | < INTEGER >
}



