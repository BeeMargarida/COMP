/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. yal2jvm.jj */
/*@egen*/options {
	LOOKAHEAD=1;                  
	           
}
 
PARSER_BEGIN(yal2jvm)

import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

public class yal2jvm/*@bgen(jjtree)*/implements yal2jvmTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTyal2jvmState jjtree = new JJTyal2jvmState();

/*@egen*/
	static java.util.Stack argStack;
	public static void main(String[] args) throws ParseException{
		argStack = new java.util.Stack(); 

		File filename = new File(args[0]);
		try { 
			yal2jvm parser = new yal2jvm(new FileInputStream(filename));
			SimpleNode root = parser.Module();
			
			root.dump("");
			
			SymbolTable symbolTable = new SymbolTable();

			System.out.println("\n\nCommencing Semantic Analysis.");
			System.out.println("Checking Operations.\n");
			
			symbolTable.fillSymbols(root);

			System.out.println("Checking Calls.\n");
			
			if (!symbolTable.hasErrors()) {
				System.out.println("\n\nCommencing Code Generation.\n\n");

				String filenameWthExt = filename.getName().replaceFirst("[.][^.]+$","");

				Sampler sampler = new Sampler("codeGenerated/" + filenameWthExt + ".j");
				Generator generator = new Generator(sampler, symbolTable);
			
				ASTModule rootModule = (ASTModule) root;
				rootModule.generatorVisit(generator);
			}
			System.out.println("\n Code Generation Done. \n");

		} catch(FileNotFoundException e) {
			System.out.println("Exception found");
		}
		
	}
}

PARSER_END(yal2jvm)

SKIP : {
	" "	| "\t"	| "\n" | "\r" | 
	<"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")> | 
	<"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/"> 
}

/* Reserved words */
TOKEN: {
	<RELA_OP : ">" | "<" | "<=" | ">=" | "==" | "!=" >
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>" >
	| <BITWISE_OP: "&" | "|" | "^" >
	| <NOT_OP: "!" >
	| <WHILE: "while">
	| <IF: "if" >
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(" >
	| <RPAR: ")" >
	| <VIRG: "," >
	| <PVIRG: ";" >
	| <DOT: "." >
	| <LCHAVETA: "{" >
	| <RCHAVETA: "}" >
	| <FUNCTION: "function" >
	| <MODULE: "module" >
	| <SIZE: "size">
}

TOKEN: {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$", "A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

// MAIN BLOCKS OF INFORMATION 

/**
 * Main Module
*/
SimpleNode Module(): {/*@bgen(jjtree) Module */
                      ASTModule jjtn000 = new ASTModule(JJTMODULE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token moduleName;} {/*@bgen(jjtree) Module */
        try {
/*@egen*/
	try {
		<MODULE> moduleName=<ID> 

		{jjtn000.name = moduleName.image; }

		<LCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on module start, with Exception thrown " + e.toString());
		Token t = getToken(0);
		try {
			if (t.kind == LCHAVETA) 
				getNextToken();
			else
				error_skipto(PVIRG);
		} catch (ParseException e2) {
			System.out.println("Error on module");
		}
	}
	
	(Declaration())*
	(Function())*
		
	try {
		< RCHAVETA > { return jjtn000; }
	} catch (ParseException e) {
		System.out.println("Error on module end, with Exception thrown " + e.toString());
		return jjtn000;	
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * Function, where the file's statement list lies.
*/
void Function(): {/*@bgen(jjtree) Function */
                  ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token name;} {/*@bgen(jjtree) Function */
        try {
/*@egen*/
	try {
	 	<FUNCTION>  name=<ID> {jjtn000.functionName = name.image; jjtn000.returnType = Utils.VOID; } (
	     	( {jjtn000.returnType = Utils.SCALAR; jjtn000.returnValue = name.image; }
				 (ArrayElement(name) {jjtn000.returnType = Utils.ARRAY; })? <ASSIGN> name=<ID> {jjtn000.functionName = name.image;})?
		     (VarList()) 
		)	
	} catch(ParseException e) {
		System.out.println("Error on function statement, with Exception thrown " + e.toString());
		try {
			error_skipto(PVIRG);
		} catch (ParseException e2) {
			System.out.println("Error on function");
		}
	} 
	
	Stmtlst()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
} 

/** 
 * Declaration, handling definitions and assignment of variables outside functions.
*/
void Declaration(): {/*@bgen(jjtree) Declaration */
                     ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/String declaration; Token tmp; Token tmp2;} {/*@bgen(jjtree) Declaration */
        try {
/*@egen*/
	
	try {	
		tmp=<ID>  
		 (ArrayElement(tmp)  {jjtn000.setType(Utils.DECLARATION_ARRAY);})?  {jjtn000.value = tmp.image;}
		(< ASSIGN > ((ArraySize()  {jjtn000.setType(Utils.DECLARATION_ARRAY);} ) | (tmp=< ADDSUB_OP > 
			{jjtn000.setOperator(tmp.image);})? tmp2=< INTEGER >{jjtn000.setAssigned(tmp2.image); jjtn000.setType(Utils.DECLARATION_SCALAR);}))?
			 < PVIRG >
	}
	catch(ParseException e) {
		System.out.println("Error on declaration, with Exception thrown " + e.toString());

		error_skipto(PVIRG);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * VarList, the set of variables of a specific function.
*/
void VarList(): {/*@bgen(jjtree) VarList */
                 ASTVarList jjtn000 = new ASTVarList(JJTVARLIST);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/String variables; Token tmp;} {/*@bgen(jjtree) VarList */
        try {
/*@egen*/ 
	try {
		<LPAR>
	} catch (ParseException e) {
		System.out.println("Error on argument list, no opening parenthesis.");
		System.out.println("Specific Exception thrown:" + e.toString());
	}
	try {
		
		(Var() 
			(< VIRG > Var()
			)*	
		)? 

		<RPAR>
	} catch (ParseException e) {
		System.out.println("Error on argument list variables or closing parenthesis.");
		System.out.println("Specific Exception thrown: "+ e.toString());
		 

		error_skipto_unless(PVIRG, RPAR);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * StmtList, the set of all statements inside a function. Opening and 
 * closing brackets are inside this list, to better detect and isolate 
 * exceptions thrown.
*/
void Stmtlst()      : {} {
	try {
		<LCHAVETA>
	} 
	catch (ParseException e) {
		System.out.println("Error on statement list, opening bracket not detected."
			+"\nSpecific exception: " + e.toString());
		error_skipto_withoutconsuming(ID);
		return;
	}

	(Stmt())* 
	
	try {
		<RCHAVETA>
	} catch (ParseException e) {
		System.out.println("Error on statement list, closing bracket not detected."
			+"\nSpecific exception: " + e.toString());
		error_skipto(ID);
	}
}

// STATEMENT INFORMATION

/**
 * Statement, the main code unit inside a function. It includes the assign
 * of variables, the call of functions, if/else blocks and while loops.
*/
void Stmt()      : {Token t;} {
	try {
		
		While() | If() | (t=<ID> (LOOKAHEAD(2) Call(t) | Assign(t))) < PVIRG >

	} catch (ParseException e) {
		System.out.println("Error on a statement, maybe missing ';'\nSpecific Exception thrown: ." 
		+ e.toString());
		error_skipto(PVIRG);
	}
}

/**
 * Call, where a method is invoked.
 * @param Token t contains ID information for printing.
*/
void Call(Token t): {/*@bgen(jjtree) Call */
                     ASTCall jjtn000 = new ASTCall(JJTCALL);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/String string; Token tmp;} {/*@bgen(jjtree) Call */
        try {
/*@egen*/
	{jjtn000.value = t.image; jjtn000.setType(Utils.CALL); jjtn000.calledFunction = t.image;}
	try {
		( < DOT > tmp=<ID > 
		{jjtn000.setType(Utils.EXTERNAL_CALL); jjtn000.packageName = (String) jjtn000.value; jjtn000.calledFunction = tmp.image;})? 
		 < LPAR > (ArgumentList() ) < RPAR >
		
	} catch (ParseException e) {
		System.out.println("Error on call."
			+"\nSpecific exception: " + e.toString());
		error_skipto_unless(PVIRG, LCHAVETA);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * Assign to handle all the assignment of variables, be they scalar or arrays.
 * @param Token t contains ID information for printing.
*/
void Assign(Token t): {/*@bgen(jjtree) Assign */
                       ASTAssign jjtn000 = new ASTAssign(JJTASSIGN);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/String string;} {/*@bgen(jjtree) Assign */
        try {
/*@egen*/
	try {
		LhsNoID(t)
		<ASSIGN> 
		Rhs()
	} catch (ParseException e) {
		System.out.println("Error on assign."
			+"\nSpecific exception: " + e.toString());
		
		error_skipto(PVIRG);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * While loop.
*/
void While(): {/*@bgen(jjtree) While */
               ASTWhile jjtn000 = new ASTWhile(JJTWHILE);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String tmp; } {/*@bgen(jjtree) While */
        try {
/*@egen*/
	try { 
		< WHILE > Exprtest() Stmtlst() 
	} catch (ParseException e) {
		System.out.println("Error on while");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * If block.
*/
void If(): {/*@bgen(jjtree) If */
             ASTIf jjtn000 = new ASTIf(JJTIF);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/ String tmp; } {/*@bgen(jjtree) If */
        try {
/*@egen*/
	try {
		< IF > Exprtest() Stmtlst() (Else())?
	} catch (ParseException e) {
		System.out.println("Error on if");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

/**
 * Else block, may or may not exist after if block.
*/
void Else(): {/*@bgen(jjtree) Else */
  ASTElse jjtn000 = new ASTElse(JJTELSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Else */
        try {
/*@egen*/
	try {
		< ELSE > Stmtlst()
	}
	catch (ParseException e) {
		System.out.println("Error on else");
		error_skipto(PVIRG);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * Lhs, the left side of a two-sided operation, such as a comparison or assigment.
 * @return String containing information of lhs block.
*/
void Lhs()      : {Token t;} {
	t=<ID>

	(ArrayAccess(t) | ScalarAccess(t)) 	
}

/**
 * LhsNoID, particular use of Lhs, specific for a function to remove ambiguity 
 * while maintaining readability.
 * @return String containing information of lhs block, excluding <ID>.
*/
void LhsNoID(Token t)      : {String tmp; } {
	(ArrayAccess(t) | ScalarAccess(t)) 
}

/**
 * Rhs, the right side of a two-sided operation, such as a comparison or assigment.
 * @return String containing information of right block.
*/
void Rhs() : {/*@bgen(jjtree) Rhs */
              ASTRhs jjtn000 = new ASTRhs(JJTRHS);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String tmp;} {/*@bgen(jjtree) Rhs */
        try {
/*@egen*/
	try {
	(
		(
		Term()((t=<ARITH_OP > | t=<BITWISE_OP> | t=< ADDSUB_OP > | t=<RELA_OP>) Term() 
			{jjtn000.setType(Utils.OP); jjtn000.jjtSetValue(t.image);})?
		) 
		|
		 ( ArrayInstantion()  )
	)
	 
	/*
	(
		(
		string=Term()((tmp=< ARITH_OP > | tmp=< BITWISE_OP > | tmp=< ADDSUB_OP >) tmpString=Term() {string += " " + tmp.image + " " + tmpString;})?
		) 
		|
		 ("[" tmpString=ArraySize() "]" {string="["+tmpString+"]";})
	)
		{return string;} 
	*/

	}
	catch (ParseException e) {
		System.out.println("Error on rhs.\nSpecific Exception thrown: " + e.toString());
		error_skipto_withoutconsuming(PVIRG);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

/**
 * Term, a subset of a Rhs.
*/
void Term(): {/*@bgen(jjtree) Term */
              ASTTerm jjtn000 = new ASTTerm(JJTTERM);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} {/*@bgen(jjtree) Term */
        try {
/*@egen*/
	try {
		( (t=<ADDSUB_OP> | t=<RELA_OP> )
			{jjtn000.setOperator(t.image);} )? 

		( (t=<INTEGER> {jjtn000.setType(Utils.NUMBER); jjtn000.value = t.image;}) 
			|
		 ( t=<ID> ( (ArrayAccess(t)) 
		  	| 
			(
				LOOKAHEAD(2) Call(t) | (ScalarAccess(t))
			)
			)
		 	)
		 )
	} catch (ParseException e) {
		System.out.println("Error on term.\nSpecific Exception: " + e.toString());
		error_skipto_withoutconsuming(PVIRG);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

/**
 * Exprtest, handles the small comparison block, present in the while and if blocks.
 * @return String containing information of right block.
*/
void Exprtest(): {/*@bgen(jjtree) Exprtest */
                  ASTExprtest jjtn000 = new ASTExprtest(JJTEXPRTEST);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; } {/*@bgen(jjtree) Exprtest */
        try {
/*@egen*/	
	try {
		< LPAR > Lhs() 
	} catch (ParseException e) {
		System.out.println("Invalid opening condition for structure. \nSpecific Exception thrown: "
		 + e.toString());
		error_skipto_withoutconsuming(RELA_OP);
	}
	try {
		t=< RELA_OP > {jjtn000.value = t.image;}
		Rhs()  <RPAR> 
	}
	catch (ParseException e) {
		System.out.println("Invalid comparison operation or ending condition for structure");
		System.out.println("Specific exception thrown: " + e.toString());
		 
		error_skipto_unless(PVIRG, RPAR);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// ARGUMENTS

/**
 * Argument List, storing the information of the arguments passed inside a call, for example.
*/
void ArgumentList(): {/*@bgen(jjtree) ArgumentList */
  ASTArgumentList jjtn000 = new ASTArgumentList(JJTARGUMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ArgumentList */
        try {
/*@egen*/
	try {

	(Argument() (< VIRG > Argument() )*)?

	} catch (ParseException e) {

		System.out.println("Invalid argument. \nSpecific Exception thrown: " + e.toString());
		error_skipto(RPAR);

	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * Argument, could be an ID, String or integer. 
 * @return String containing information of argument.
*/
void Argument() : {/*@bgen(jjtree) Argument */
                   ASTArgument jjtn000 = new ASTArgument(JJTARGUMENT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; } {/*@bgen(jjtree) Argument */
         try {
/*@egen*/
	 (t=<ID> | t=<STRING> | t=<INTEGER> {jjtn000.type = Utils.NUMBER;} )/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/{jjtn000.content = t.image;}/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

// ACCESS

/**
 * Array Size. Contains the information of the size of an array
 * @return String with the information of the array size.
*/
void ArraySize()      : { Token tmp; Token tmp2;} {
	(LOOKAHEAD(2) ArrayInstantion() | ("[" tmp=<ID> ScalarAccess(tmp) "]"))
}

/**
 * Array Access, accessing information of an array.
 * @return String containing information of array access, specifically the index..
*/
void ArrayAccess(Token content) :  {/*@bgen(jjtree) ArrayAccess */
                                    ASTArrayAccess jjtn000 = new ASTArrayAccess(JJTARRAYACCESS);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/String index;} {/*@bgen(jjtree) ArrayAccess */
        try {
/*@egen*/
	"[" index=Index() "]"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{jjtn000.content = content.image; jjtn000.index = index; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ArrayInstantion() : {/*@bgen(jjtree) ArrayInstantion */
                          ASTArrayInstantion jjtn000 = new ASTArrayInstantion(JJTARRAYINSTANTION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/String size;} {/*@bgen(jjtree) ArrayInstantion */
        try {
/*@egen*/
	"[" size=Index() "]"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.size = size; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * Scalar Access.
 * @return String containing information of size, or nothing if no '.' is found.
*/
void ScalarAccess(Token content) :  {/*@bgen(jjtree) ScalarAccess */
                                     ASTScalarAccess jjtn000 = new ASTScalarAccess(JJTSCALARACCESS);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token size; } {/*@bgen(jjtree) ScalarAccess */
        try {
/*@egen*/
	{jjtn000.value = content.image;} (<DOT > size=< SIZE > {jjtn000.setType(Utils.SIZE);})?/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/**
 * Index of an array.
 * @return String with index.
*/
String Index()      : {Token value;} {
	(value=< ID > | value=< INTEGER >)
	{return value.image;}
}

void Var() : {/*@bgen(jjtree) Var */
              ASTVar jjtn000 = new ASTVar(JJTVAR);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String tmp;} {/*@bgen(jjtree) Var */
        try {
/*@egen*/
	t=<ID> {jjtn000.value = t.image; jjtn000.setType(Utils.SCALAR); } 
	
	(ArrayElement(t) {jjtn000.value = null; jjtn000.setType(Utils.ARRAY); })?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * Array Element, checks to see if the element is correctly formatted, important for
 * error recovery.
*/
void ArrayElement(Token t): {/*@bgen(jjtree) ArrayElement */
  ASTArrayElement jjtn000 = new ASTArrayElement(JJTARRAYELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) ArrayElement */
        try {
/*@egen*/
	"[" "]"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// ERROR RECOVERY

/**
 * Skips all tokens until a specific character is found.
*/
JAVACODE
void error_skipto(int kind) {/*@bgen(jjtree) error_skipto */
ASTerror_skipto jjtn000 = new ASTerror_skipto(JJTERROR_SKIPTO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


/**
 * Skips all tokens until a specific character is found, or another more important
 * but less likely token appears unexpectedly.
*/
JAVACODE
void error_skipto_unless(int kind, int stopKind) {/*@bgen(jjtree) error_skipto_unless */
ASTerror_skipto_unless jjtn000 = new ASTerror_skipto_unless(JJTERROR_SKIPTO_UNLESS);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind && t.kind != stopKind);/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/**
 * Skips all tokens until a specific character, without consuming that specific token.
*/
JAVACODE
void error_skipto_withoutconsuming(int kind) {/*@bgen(jjtree) error_skipto_withoutconsuming */
ASTerror_skipto_withoutconsuming jjtn000 = new ASTerror_skipto_withoutconsuming(JJTERROR_SKIPTO_WITHOUTCONSUMING);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {
/*@egen*/
  Token t;

  boolean hasReached = false;
  while (!hasReached) {
  	t = getToken(1);
  	if (t.kind == kind)
  		hasReached = true;
  	else 
  		getNextToken();
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}